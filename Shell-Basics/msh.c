#define _GNU_SOURCE

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <signal.h>

// this is the number of characters a single line of command will take
#define MAX_COMMAND_SIZE 255
#define MAX_ARGS 11
#define SINGLE_COMMAND_SIZE 32
#define TOK_DELIM " \r\n\t\a"
#define MAX_HIST 15


// PIDS and command history will be stored in global variables
int PIDS[MAX_HIST+1];                   // array stores last 15 PIDS
char *history[MAX_HIST+1];              // array stores last 15 commands
char cwd[MAX_COMMAND_SIZE];             // to store curr working directory
char root[MAX_COMMAND_SIZE];            // stores directory with script file
char dir[MAX_COMMAND_SIZE];             // stores dorectory name

// displays pids generated by the last 15 forks
void display_pids()
{
    int i;
    for(i = 0; PIDS[i] != -1; i++)
    {
        printf("%d: %d\n",i,PIDS[i]);
    }
}

// displays the last 15 commands entered
void display_history()
{
    int i;
    for(i = 0; history[i] != NULL; i++)
    {
        printf("%d: %s\n",i,history[i]);
    }
}

char *string_reverse(char *str, char *rev_str)
{
    int length = strlen(str);
    int j = length - 1;
    int i;
    rev_str = (char *)malloc(sizeof(char) * length+1);
    for(i = 0; i<length; i++)
    {
        rev_str[i] = str[j];
        j--;
    }
    rev_str[length] = '\0';
    return rev_str;
}

// reads single line of command from the shell
char *read_single_line()
{
    // save number of characters to resize buffer
    int no_of_chars = 0;
    char c;

    //set initial buffer size
    size_t buffersize = MAX_COMMAND_SIZE;
    char *buffer = (char *)malloc(sizeof(char) * buffersize);

    if (buffer == NULL)
    {
        fprintf(stderr,"allocation failure\n");
        exit(EXIT_FAILURE);
    }

    do
    {   
        c = getchar();
        // if the first char entered is return, the user will 
        // be prompted to re-enter the command 
        if(c == '\n' && no_of_chars == 0)
        {
            printf("msh%s> ", dir);
            // start loop from top as no command has been entered
            continue;
        }
        else if(c == '\n')
        {
            // exit loop as command is complete
            break;
        } 
        buffer[no_of_chars] = c;
        no_of_chars++;

        // if command size is equal to buffer size, resize
        if(no_of_chars == buffersize)
        {
            buffersize = buffersize * 2;
            buffer = (char *)realloc(buffer, sizeof(char) * buffersize);
        }
    }while(1);

    // add null character to end of string
    buffer[no_of_chars] = '\0';
    buffer = strtok(buffer,"\n");
    return buffer;
}

//this function takes a single line of command line arguments and breaks it into a array of arguments
char **get_args(char *single_line)
{
    int str_len, i, j;
    // stores a copy of single_line
    char *single_line_copy;
    char **args;

    // command will only be parsed if no of parameters is within limit
    // parse status will be set to 1 if no of parameters is < 11
    int parse_status = 0;   

    do
    {
        // count number of arguments so it does not exceed MAX_ARGS
        int no_of_args = 0;
        str_len = strlen(single_line);

        // allocate memory to copy single_line as strtok destroys
        // the string being parsed and we will use strtok twice 
        single_line_copy = (char *)malloc(sizeof(char) * (str_len+1));
        strcpy(single_line_copy,single_line);

        // use strtok on single_line_copy to count number of arguments
        char *token = NULL;
        char *token2 = NULL;
        token = strtok(single_line_copy,TOK_DELIM);
        while (token != NULL)
        {
            no_of_args++;
            token = strtok(NULL,TOK_DELIM);     
        }

        // if number of arguments exceeds MAX_ARGS, prompt user to re-enter the command
        if(no_of_args > MAX_ARGS)
        {
            ("msh: too many arguments: max allowed 11\n");
            printf("msh%s> ",dir);
            single_line = read_single_line();
            single_line = strtok(single_line,"\n");
            free(single_line_copy);
        }
        else
        {
            // allocate memory to save arguments as an array of
            // strings followed by NULL characters
            args = malloc(sizeof(char *) * (MAX_ARGS + no_of_args));   
            token2 = strtok(single_line,TOK_DELIM);
            args[0] = (char *)malloc(sizeof(char) * SINGLE_COMMAND_SIZE);
            strcpy(args[0],token2);
            for(i = 1; i <= no_of_args; i++)
            {
                token2 = strtok(NULL,TOK_DELIM);
                if(token2 == NULL)   // if current argument is the last argument
                {
                    // add as many NULL characters at end as
                    // the number of arguments
                    for(j = 0; j < no_of_args; j++)
                    {
                        args[i+j] = NULL;
                    }
                    // set parse status as complete
                    parse_status = 1;  
                }
                else{
                    args[i] = (char *)malloc(sizeof(char) * SINGLE_COMMAND_SIZE);
                    strcpy(args[i],token2);
                }
            }
        }    
    }while(!parse_status);

    free(single_line_copy);

    return args;
}

// this function runs the command line arguments passed as an array of strings, keeps track of the last 15 pids and commands
int run_args(char **args, int *no_of_pids, char *single_line_hist)
{
    pid_t pid;
    if(strcmp(args[0],"exit") == 0 || strcmp(args[0],"quit") == 0)
    {
        return 0;
    }
    else
    {
        // create a new process for all commands except "exit" & "quit"
        pid = fork();
        if(pid == 0)  // child
        {
            if(strcmp(args[0],"history") == 0)
            {
                // display history and exit normally
                display_history();
                exit(1);
            }
            else if(strcmp(args[0],"showpids") == 0)
            {
                // display pids and exit normally
                display_pids();
                exit(1);
            }
            else if(strcmp(args[0],"cd") == 0)
            {
                // exit normally
                exit(1);
            }
            else
            {
                // execute the command
                int ret = execvp(args[0], &args[0]);  
                if(ret == -1)
                {
                    printf("%s: Command not found.\n",args[0]);
                    exit(1);
                }
            }
        }
        else  //parent
        {      
            int status;
            waitpid(pid,&status,0);
            
            // to change directory
            if(strcmp(args[0],"cd") == 0)
            {
                // to store value returned by chdir(); 0 on success
                int ret;
                if(strcmp(args[1],"..") == 0)
                {
                    // get current path
                    getcwd(cwd,sizeof(cwd));
                    char *path;
                    char *token;

                    // reverse the string to remove the current folder
                    // from the path using strtok with "/"
                    // if path is /home/sxr/os/msh this process will store /home/sxr/os in path
                    // to move one directory back
                    path = string_reverse(cwd,path);
                    token = strtok(path," /");
                    token = strtok(NULL," \n");
                    path = string_reverse(token,path);
                    ret = chdir(path);

                    // if user moves further back than root, don't display change in path
                    if(strlen(path) <= strlen(root))
                    {
                        strcpy(dir,"");
                    }
                    else
                    {  
                        // remove last directory from path and display
                        char *curr_dir;
                        char *curr_dir2;
                        curr_dir = string_reverse(dir,curr_dir);
                        token = strtok(curr_dir," /");
                        token = strtok(NULL," \n");
                        curr_dir2 = string_reverse(token,curr_dir2);
                        strcpy(dir,curr_dir2);
                        free(curr_dir);
                        free(curr_dir2);
                    }
                    free(path);
                }
                else 
                {
                    // chage directory according to argument and display
                    ret = chdir(args[1]);
                    getcwd(cwd,sizeof(cwd));
                    if((strlen(cwd) <= strlen(root)) && !ret)
                    {
                        strcpy(dir,"");
                    }
                    else if(!ret)
                    {
                        strcat(dir,"/");
                        strcat(dir,args[1]);
                    }   
                }
                
                 // if chdir was successful i.e. ret = 0
                if(ret)
                {
                    printf("%s: %s: No such file or directory\n",args[0], args[1]);
                }
            }

            // dynamically allocate space to record commands for history and store them
            // increase the no_of_pids count after storing command and pid
            if(WIFEXITED(status) && (*no_of_pids < MAX_HIST))
            {
                history[*no_of_pids] = (char *)malloc(sizeof(char) * MAX_COMMAND_SIZE);
                strcpy(history[*no_of_pids],single_line_hist);
                // store last element = NULL to determine end of array
                history[*no_of_pids + 1] = NULL;
                PIDS[*no_of_pids] = pid;
                // store last element = -1 to determine end of array
                PIDS[*no_of_pids + 1] = -1;
                *no_of_pids = *no_of_pids + 1;
            }

            // if no_of_pids is equal to 15 i.e. max no. of history and pids that can be displayed
            // discard the oldest command and pid, shift remaining elements and add latest command and pid
            else if (WIFEXITED(status) && (*no_of_pids == MAX_HIST))
            {
                int i;
                for(i = 0; i < MAX_HIST-1; i++)
                {
                    strcpy(history[i],history[i+1]);
                    PIDS[i] = PIDS[i+1];
                }
                strcpy(history[*no_of_pids-1],single_line_hist);
                PIDS[*no_of_pids-1] = pid;
            }
        }
    }
    return 1;
}

// frees all elements of a 2D array allocated dynamically
int free_array(char **arr)
{
    int i;
    for(i = 0;arr[i] != NULL;i++)
    {
        free(arr[i]);
    }
    free(arr);
    return 1;
}

int main(int argc, char * argv[])
{
    
    int status = 1;                     // will remain 1 until "exit" or "quit"
    int no_of_pids = 0;                 // keeps track of no of processes
    char *single_line;                  // will hold single line of command enterted
    char *single_line_hist;             // copy of single_line to store in history array
    char **args;                        // single line command will be parsed and stored in args                     
    getcwd(root,sizeof(root));          // set root as cwd

    // value of dir will be empty if in root dir
    // will change to corresponding folder navigated to using cd <foldername>
    strcpy(dir,"");

    do
    {
        printf("msh%s> ",dir);

        // read single line of command
        single_line = read_single_line();

        // store command to record history
        single_line_hist = (char *)malloc(sizeof(char) * (strlen(single_line)+1));
        strcpy(single_line_hist,single_line);

        // break commands into an array of strings
        args = get_args(single_line);

        // if command is "!n", command will be pulled from history array
        if(args[0][0] == '!')
        {
            // get n from !n
            char *token = strtok(args[0]," !\n");

            // if nth command is in record
            if((atoi(token) < no_of_pids) && (no_of_pids < MAX_HIST))
            {
                // get command from history and run
                int hist_no = atoi(token);
                strcpy(single_line,history[hist_no]);
                strcpy(single_line_hist,single_line);
                args = get_args(single_line);
                status = run_args(args,&no_of_pids,single_line_hist);
            }
            else if((atoi(token) < no_of_pids) && (no_of_pids == MAX_HIST))
            {
                int hist_no = atoi(token) - 1;
                strcpy(single_line,history[hist_no]);
                strcpy(single_line_hist,single_line);
                args = get_args(single_line);
                status = run_args(args,&no_of_pids,single_line_hist);
            }
            // if nth command is not recorded in history
            else
            {
                printf("Command not in history.\n");
            }
        }
        else
        {
            status = run_args(args,&no_of_pids,single_line_hist);
        }
        
        // free dyamically allocated variables
        free(single_line);
        free(single_line_hist);
        free_array(args);

    }while(status);

    return 0;
}
